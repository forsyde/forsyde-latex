% Author: George Ungureanu <ugeorge@kth.se>
% Date: 29.01.2017
%
% This file contains macros for drawing all nodes


%%%%%%%%%%%%%%%%%%%%%%%
% GLOBAL DECLARATIONS %
%%%%%%%%%%%%%%%%%%%%%%%

\pgfdeclarelayer{backbackground}
\pgfdeclarelayer{background}
\pgfdeclarelayer{foreground}
\pgfsetlayers{backbackground,background,main,foreground}

%%%%%%%%%%%
% HELPERS %
%%%%%%%%%%%


\newcommand\addcase[3]{%
  \expandafter\def\csname\string#1@case@#2\endcsname{#3}%
}
\newcommand\makeswitch[2][]{%
  \newcommand#2[1]{%
    \ifcsname\string#2@case@##1\endcsname\csname\string#2@case@##1\endcsname\else#1\fi%
  }%
}

\makeswitch[]\getmoclabel
\addcase\getmoclabel{sy}{SY}
\addcase\getmoclabel{de}{DE}
\addcase\getmoclabel{ct}{CT}
\addcase\getmoclabel{sdf}{SDF}

\makeswitch[\defaultfillcolor]\getfieldcolor
\addcase\getfieldcolor{sy}{sycolor}
\addcase\getfieldcolor{de}{decolor}
\addcase\getfieldcolor{ct}{ctcolor}
\addcase\getfieldcolor{sdf}{sdfcolor}
\addcase\getfieldcolor{blackbox}{blackboxcolor}

\newcommand\getcolor[3]{%
  \iftoggle{#1}%
    {\edef#3{\ifnocolor\defaultfillcolor\else\getfieldcolor{#2}\fi}}%
    {\edef#3{\getfieldcolor{#2}}%
  }%
}

\newcommand{\functionlabels}[5]{ %#1=nf, #2... = functions
  \ifnum #1>0 \nodepart{fa} #2\else\fi%
  \ifnum #1>1 \nodepart{fb} #3\else\fi%
  \ifnum #1>2 \nodepart{fc} #4\else\fi%
  \ifnum #1>3 \nodepart{fd} #5\else\fi%
}

%%%%%%%%%%%%%%%%%%%%% 
% MACRO DEFINITIONS %
%%%%%%%%%%%%%%%%%%%%%

% The basic node is the simplest depiction of a function (atom,
% pattern) with maximum one argument. It is represented as a circle
% node.
%
% \basic[keys] (name) [<position>] {label};
\NewDocumentCommand\basic{O{} D(){} D<>{0,0} m}{
  \pgfkeys{/forsyde keys, default, #1}%
  \ifnum \fsdNFunctions>1 \edef\numFunc{1} \else \edef\numFunc{\fsdNFunctions} \fi%
  \coordinate (globalPos) at (#3);
  \node[\fsdShape,
    yshift=\fsdYShift, xshift=\fsdXShift,
    anchor=\fsdAnchor] (#2) at ($(globalPos) + (\fsdAtInit)$) {#4};
  \begin{pgfonlayer}{foreground}
    \node[func\numFunc, font=\funcStyle, anchor=south](#2-f) at (#2.north){
      \functionlabels{\fsdNFunctions}{\fsdFunA}{}{}{}};
  \end{pgfonlayer}   
}


% The standard node is a more complex depiction of a ForSyDe block. It
% contains anchors for each port, shows a label and the constructor
% name, and its field is colored according to a MoC (if this is the
% case).
%
% \standard[keys] (name) [<position>] {label};
\NewDocumentCommand\standard{O{} D(){} D<>{0,0} m}{
  \pgfkeys{/forsyde keys, default, #1}%
  \coordinate (globalPos) at (#3);
  \getcolor{/forsyde keys/hasmoc}{\fsdMoc}{\fillcolor}
  \node[%
  ports i\fsdNPortLeft o\fsdNPortRight,
  anchor=\fsdAnchor,
  yshift=\fsdYShift,
  xshift=\fsdXShift,
  rotate=\fsdRotate,
  inner sep=0,
  ] (#2) at ($(globalPos) + (\fsdAtInit)$) {%
    \begin{tikzpicture}
      % a label should be in the center, controlled with \labelStyle
      \node[] (#2-l) at (0,0) {\labelStyle{#4}};
      % the functions are inside the scope, above the label
      \node[func\fsdNFunctions, font=\funcStyle,yshift=\fsdInnerYSep, anchor=south]
      (#2-f) at (#2-l.north) {%
        \functionlabels{\fsdNFunctions}%
        {\fsdFunA}{\fsdFunB}{\fsdFunC}{\fsdFunD}
      };
      % the type (constructor) is positioned below the label
      \node[yshift=-\fsdInnerYSep,inner sep=2pt, anchor=north]
      (#2-t) at (#2-l.south){%
        \typeStyle{\fsdType \ifnolabel\else\getmoclabel{\fsdMoc}\fi}
      };
      % The main shape is behind any other graphical element.
      \begin{pgfonlayer}{background}
        \node[\fsdShape,
        fill=\fillcolor,
        rotate=\fsdRotateShape,
        fit=(#2-f)(#2-l)(#2-t)] {};
      \end{pgfonlayer}
    \end{tikzpicture}
  };
  \node[] at (#2.south) {};
}

\NewDocumentCommand\crossed{O{} D(){} D<>{0,0} m}{
  \pgfkeys{/forsyde keys, default, #1}%
  \coordinate (globalPos) at (#3);
  \ifnum \fsdRotate >0 \def\labelrot{-90} \else \def\labelrot{90} \fi
  \node[%
  ports i\fsdNPortLeft o\fsdNPortRight,
  anchor=\fsdAnchor,
  yshift=\fsdYShift,
  xshift=\fsdXShift,
  rotate=\fsdRotate,
  inner sep=0,
  ] (#2) at ($(globalPos) + (\fsdAtInit)$) {%
    \begin{tikzpicture}
      \node[rotate=\labelrot, inner sep=3pt] (#2-t) {\typeStyle{\fsdType}};
      \node[fit=(#2-t)] (#2-wt) {};
      \begin{pgfonlayer}{foreground}
        \node[func\fsdNFunctions, font=\funcStyle, anchor=south](#2-f) at (#2-wt.north){
          \functionlabels{\fsdNFunctions}{\fsdFunA}{\fsdFunB}{\fsdFunC}{\fsdFunD}};
      \end{pgfonlayer}
      \node[\fsdShape, draw, fit=(#2-wt), rotate=\fsdRotateShape,] (#2-out) {};
    \end{tikzpicture}
  };
  \node[] at (#2.south) {};
}

% Interface
\NewDocumentCommand\interface{O{} D(){} D<>{0,0} m m}{
% \newcommand{\interface}[3][]{
  \pgfkeys{/forsyde keys, default, #1}%
  \coordinate (globalPos) at (#3);
  \getcolor{/tikz/alwaystrue}{#4}{\fillcolorl}
  \getcolor{/tikz/alwaystrue}{#5}{\fillcolorr}
  \node[%
  ports i1o1,
  anchor=\fsdAnchor,
  yshift=\fsdYShift,
  xshift=\fsdXShift,
  rotate=\fsdRotate,
  inner sep=0,
  ] (#2) at ($(globalPos) + (\fsdAtInit)$) {% 
    \begin{tikzpicture}
      \node[anchor=south east, inner sep=3pt] (#2-l) {%
        \typeStyle{\ifnolabel\else\getmoclabel{#4}\fi}};
      \node[anchor=north west, inner sep=3pt] (#2-r) at (#2-l.south east) {%
        \typeStyle{\ifnolabel\else\getmoclabel{#5}\fi}};
      \gettikzxy{(#2-l.north west)}{\xl}{\yl}
      \gettikzxy{(#2-r.south east)}{\xr}{\yr}
      \begin{pgfonlayer}{background}
        \filldraw[fill=\fillcolorl] (\xl,\yl) -- (\xl,\yr) -- (\xr,\yl) -- cycle;
        \filldraw[fill=\fillcolorr] (\xr,\yl) -- (\xr,\yr) -- (\xl,\yr) -- cycle;
      \end{pgfonlayer} 
    \end{tikzpicture}
  };
  \node[] at (#2.south) {};
}

% Cluster node. Instead of taking a coordinate, it takes a list of
% nodes and draws the shape around them.
% #1 = keys
% #2 = name
% #3 = list of nodes clustered
% #4 = label
\NewDocumentCommand\cluster{O{} D(){} r<> m}{
  \pgfkeys{/forsyde keys, default, #1}%
  \getcolor{/forsyde keys/hasmoc}{\fsdMoc}{\fillcolor}
  % the scope now contains only the cluster shape and the
  % labels. Functions are outside of it.
  \begin{scope}[local bounding box=#2]
    % cluster shape
    \begin{pgfonlayer}{backbackground}
    \node[\fsdShape,
      inner xsep=\fsdInnerXSep,
      inner ysep=\fsdInnerYSep, 
      fill=\fillcolor,
      fit=#3, rotate=\fsdRotateShape] (#2-s) {};
    \end{pgfonlayer}
    % label
    \node[anchor=south east] (#2-l) at (#2-s.south east){
      \footnotesize\labelStyle{#4}};
    % constructor  
    \node[anchor=south west] (#2-t) at (#2-s.south west){
      \typeStyle{\fsdType}}; 
  \end{scope}
  \node[ports i\fsdNPortLeft o\fsdNPortRight, inner sep=0, fit=(#2-s)(#2-t)(#2-l)] {};
  % the functions are in foreground, outside the scope of the cluster.
  \begin{pgfonlayer}{foreground}
    \node[func\fsdNFunctions,
    font=\funcStyle,
    anchor=south west] (#2-f) at (#2-s.north west) {%
      \functionlabels{\fsdNFunctions}%
      {\fsdFunA}{\fsdFunB}{\fsdFunC}{\fsdFunD}};
  \end{pgfonlayer}
  \path[name path=#2-left]   (#2.north west) -- (south west);
  \path[name path=#2-right]  (#2.north east) -- (south east);
  \path[name path=#2-top]    (#2.north west) -- (north east);
  \path[name path=#2-bottom] (#2.south west) -- (south east);
}


% Custom transition pattern
% #1 = keys
% #2 = name
% #3 = position
\newcommand\patternnodecustom[3][]{
  \pgfkeys{/transition patterns keys, default, #1}%
  \pgfmathtruncatemacro\rotports{\iftoggle{/transition patterns keys/reverse}{180}{0}}
  \pgfmathtruncatemacro\rotshape{\iftoggle{/transition patterns keys/reverse shape}
    {\iftoggle{/transition patterns keys/reverse}{0}{180}}
    {\iftoggle{/transition patterns keys/reverse}{180}{0}}}
  \begin{scope}[local bounding box= #2, shift={(#3)}]	
    \begin{scope}	
      \node[\pInnerShape, rotate=\rotports] (#2-c) at (0,0) {};
      \node[func\pNFunc, font=\funcStyle, anchor=south] (#2-f) at (#2-c.north) 
      {\functionlabels{\pNFunc}{\pFuncA}{\pFuncB}{\pFuncC}{\pFuncD}};
      \node[\pShape, draw, inner xsep=0pt, inner ysep=1pt, fit=(#2-c), rotate=\rotshape,] 
      (#2-oshape) {};
      \node[ports i\pNIn o\pNOut, rotate=\rotports, inner sep=0pt, fit=(#2-oshape),] (#2-p) {};
    \end{scope}
  \end{scope}
}
