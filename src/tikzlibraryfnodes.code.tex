% Author: George Ungureanu <ugeorge@kth.se>
% Date: 29.01.2017
%
% This file contains macros for drawing all nodes


%%%%%%%%%%%%%%%%%%%%%%%
% GLOBAL DECLARATIONS %
%%%%%%%%%%%%%%%%%%%%%%%

\pgfdeclarelayer{backbackground}
\pgfdeclarelayer{background}
\pgfdeclarelayer{foreground}
\pgfsetlayers{backbackground,background,main,foreground}

\makeswitch[]\getmoclabel
\addcase\getmoclabel{sy}{SY}
\addcase\getmoclabel{de}{DE}
\addcase\getmoclabel{ct}{CT}
\addcase\getmoclabel{sdf}{SDF}

\makeswitch[\defaultfillcolor]\getfieldcolor
\addcase\getfieldcolor{sy}{sycolor}
\addcase\getfieldcolor{de}{decolor}
\addcase\getfieldcolor{ct}{ctcolor}
\addcase\getfieldcolor{sdf}{sdfcolor}
\addcase\getfieldcolor{blackbox}{blackboxcolor}

\newcommand\getcolor[3]{%
  \iftoggle{#1}%
    {\edef#3{\ifnocolor\defaultfillcolor\else\getfieldcolor{#2}\fi}}%
    {\edef#3{\getfieldcolor{#2}}%
  }%
}

\newcommand{\functionlabels}[5]{ %#1=nf, #2... = functions
  \ifnum #1>0 \nodepart{fa} #2\else\fi%
  \ifnum #1>1 \nodepart{fb} #3\else\fi%
  \ifnum #1>2 \nodepart{fc} #4\else\fi%
  \ifnum #1>3 \nodepart{fd} #5\else\fi%
}

%%%%%%%%%%%%%%%%%% 
% DRAW FUNCTIONS %
%%%%%%%%%%%%%%%%%%

% The basic node is the simplest depiction of a function (atom,
% pattern) with maximum one argument. It is represented as a circle
% node.
%
% \basic[keys] [(name)] [<position>] {label};
\NewDocumentCommand\basic{O{} D(){} D<>{0,0} m}{
  \pgfkeys{/forsyde keys, default, #1}%
  \ifnum \fsdNFunctions>1 \edef\numFunc{1} \else \edef\numFunc{\fsdNFunctions} \fi%
  \coordinate (globalPos) at (#3);
  \node[\fsdShape,
    yshift=\fsdYShift, xshift=\fsdXShift,
    anchor=\fsdAnchor] (#2) at ($(globalPos) + (\fsdAtInit)$) {#4};
  \begin{pgfonlayer}{foreground}
    \node[func\numFunc, font=\funcStyle, anchor=south](#2-f) at (#2.north){
      \functionlabels{\fsdNFunctions}{\fsdFunA}{}{}{}};
  \end{pgfonlayer}   
}


% The standard node is a more complex depiction of a ForSyDe block. It
% contains anchors for each port, shows a label and the constructor
% name, and its field is colored according to a MoC (if this is the
% case).
%
% \standard[keys] [(name)] [<position>] {label};
\NewDocumentCommand\standard{O{} D(){} D<>{0,0} m}{
  \pgfkeys{/forsyde keys, default, #1}%
  \coordinate (globalPos) at (#3);
  \getcolor{/forsyde keys/hasmoc}{\fsdClass}{\fillcolor}
  \node[%
  ports e\fsdNPortLeft w\fsdNPortRight,
  anchor=\fsdAnchor,
  yshift=\fsdYShift,
  xshift=\fsdXShift,
  rotate=\fsdRotate,
  inner sep=0, outer sep=0,
  ] (#2) at ($(globalPos) + (\fsdAtInit)$) {%
    \begin{tikzpicture}
      % a label should be in the center, controlled with \labelStyle
      \node[] (#2-l) at (0,0) {\labelStyle{#4}};
      % the functions are inside the scope, above the label
      \node[func\fsdNFunctions, font=\funcStyle,yshift=\fsdInnerYSep, anchor=south]
      (#2-f) at (#2-l.north) {%
        \functionlabels{\fsdNFunctions}%
        {\fsdFunA}{\fsdFunB}{\fsdFunC}{\fsdFunD}
      };
      % the type (constructor) is positioned below the label
      \node[yshift=-\fsdInnerYSep,inner sep=2pt, anchor=north]
      (#2-t) at (#2-l.south){%
        \typeStyle{\fsdType \ifnolabel\else\getmoclabel{\fsdClass}\fi}
      };
      % The main shape is behind any other graphical element.
      \begin{pgfonlayer}{background}
        \node[\fsdShape,
        fill=\fillcolor,
        rotate=\fsdRotateShape,
        fit=(#2-f)(#2-l)(#2-t)] {};
      \end{pgfonlayer}
    \end{tikzpicture}
  };
  % we need to draw the functions again to make their anchors accessible
  % \node[func\fsdNFunctions, font=\funcStyle,yshift=\fsdInnerYSep, anchor=north]
  % (#2-f) at (#2.north) {%
  %   \functionlabels{\fsdNFunctions}%
  %   {\fsdFunA}{\fsdFunB}{\fsdFunC}{\fsdFunD}
  % };
  % dummy nodes for scaling bugs.
  \node[] at (#2.south west) {}; \node[] at (#2.north east) {};
}

% A transversal node over a path (usually 90 degrees), which
% symbolizes a structural transition of the path's type
% (e.g. permutation). The label is ignored, but it is necessary to
% mark the end of the arguments.
%
% \trans[keys] [(name)] [<position>] {};
\NewDocumentCommand\trans{O{} D(){} D<>{0,0} m}{
  \pgfkeys{/forsyde keys, default, #1}%
  \coordinate (globalPos) at (#3);
  \ifnum \fsdRotate >0 \def\labelrot{-90} \else \def\labelrot{90} \fi
  \node[%
  ports e\fsdNPortLeft w\fsdNPortRight,
  anchor=\fsdAnchor,
  yshift=\fsdYShift,
  xshift=\fsdXShift,
  rotate=\fsdRotate,
  inner sep=0,
  ] (#2) at ($(globalPos) + (\fsdAtInit)$) {%
    \begin{tikzpicture}
      \node[rotate=\labelrot, inner xsep=\fsdInnerYSep, inner ysep=3pt] (#2-t) {\typeStyle{\fsdType}};
      \node[fit=(#2-t)] (#2-wt) {};
      \node[\fsdShape, draw, fit=(#2-wt), rotate=\fsdRotateShape,] (#2-out) {};
    \end{tikzpicture}
  };
  \begin{pgfonlayer}{foreground}
    \node[func\fsdNFunctions, font=\funcStyle, anchor=south,rotate=\fsdRotate,](#2-f) at (#2.north){
      \functionlabels{\fsdNFunctions}{\fsdFunA}{\fsdFunB}{\fsdFunC}{\fsdFunD}};
  \end{pgfonlayer}
  % dummy nodes for scaling bugs.
  \node[] at (#2.south west) {}; \node[] at (#2.north east) {};
}

% An interface from one domain to another (e.g. a MoC interface).
%
% \interface[keys] [(name)] [<position>] {domain-left} {domain-right};
\NewDocumentCommand\interface{O{} D(){} D<>{0,0} m m}{
  \pgfkeys{/forsyde keys, default, #1}%
  \coordinate (globalPos) at (#3);
  \getcolor{/tikz/alwaystrue}{#4}{\fillcolorl}
  \getcolor{/tikz/alwaystrue}{#5}{\fillcolorr}
  \node[%
  ports e1w1,
  anchor=\fsdAnchor,
  yshift=\fsdYShift,
  xshift=\fsdXShift,
  rotate=\fsdRotate,
  inner sep=0,
  ] (#2) at ($(globalPos) + (\fsdAtInit)$) {% 
    \begin{tikzpicture}
      \node[anchor=south east, inner sep=3pt] (#2-l) {%
        \typeStyle{\ifnolabel\else\getmoclabel{#4}\fi}};
      \node[anchor=north west, inner sep=3pt] (#2-r) at (#2-l.south east) {%
        \typeStyle{\ifnolabel\else\getmoclabel{#5}\fi}};
      \gettikzxy{(#2-l.north west)}{\xl}{\yl}
      \gettikzxy{(#2-r.south east)}{\xr}{\yr}
      \begin{pgfonlayer}{background}
        \filldraw[fill=\fillcolorl] (\xl,\yl) -- (\xl,\yr) -- (\xr,\yl) -- cycle;
        \filldraw[fill=\fillcolorr] (\xr,\yl) -- (\xr,\yr) -- (\xl,\yr) -- cycle;
      \end{pgfonlayer} 
    \end{tikzpicture}
  };
  % dummy nodes for scaling bugs.
  \node[] at (#2.south west) {}; \node[] at (#2.north east) {};
}


% A cluster around other nodes. Instead of a position, it requires a
% list of nodes.
%
% \cluster[keys] [(name)] <(list)(of)(nodes)> {label};
\NewDocumentCommand\cluster{O{} D(){} r<> m}{
  \pgfkeys{/forsyde keys, default, #1}%
  \getcolor{/forsyde keys/hasmoc}{\fsdClass}{\fillcolor}
  % the scope now contains only the cluster shape and the
  % labels. Functions are outside of it.
  \begin{scope}[local bounding box=#2]
    % cluster shape
    \begin{pgfonlayer}{backbackground}
    \node[\fsdShape,
      inner xsep=\fsdInnerXSep,
      inner ysep=\fsdInnerYSep, 
      fill=\fillcolor,
      fit=#3, rotate=\fsdRotateShape] (#2-s) {};
    \end{pgfonlayer}
    % label
    \node[anchor=south east] (#2-l) at (#2-s.south east){
      \footnotesize\labelStyle{#4}};
    % constructor  
    \node[anchor=south west] (#2-t) at (#2-s.south west){
      \typeStyle{\fsdType}}; 
  \end{scope}
  \node[ports e\fsdNPortLeft w\fsdNPortRight, inner sep=0, fit=(#2-s)(#2-t)(#2-l)] (#2) {};
  % the functions are in foreground, outside the scope of the cluster.
  \begin{pgfonlayer}{foreground}
    \node[func\fsdNFunctions,
    font=\funcStyle,
    anchor=south west] (#2-f) at (#2-s.north west) {%
      \functionlabels{\fsdNFunctions}%
      {\fsdFunA}{\fsdFunB}{\fsdFunC}{\fsdFunD}};
  \end{pgfonlayer}
  \path[name path=#2-left]   (#2.north west) -- (#2.south west);
  \path[name path=#2-right]  (#2.north east) -- (#2.south east);
  \path[name path=#2-top]    (#2.north west) -- (#2.north east);
  \path[name path=#2-bottom] (#2.south west) -- (#2.south east);
}


% Draws conduit from ports
% #1 = length
% #2 = inner node
% #3 = number of ports on the east
% #3 = number of ports on the west
\newcommand{\drawconduit}[4][2pt]{
  \foreach \i in {0,...,#3} { \draw[line width=.3pt] (#2.w\i) -- +(-#1,0); }
  \foreach \i in {0,...,#3} { \draw[line width=.3pt] (#2.e\i) -- +(#1,0); }
}

